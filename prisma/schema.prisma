// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  EMPLOYEE
  HR
  SECURITY
  OA
}

enum RelationshipType {
  DIRECT_REPORT
  TEAM_LEAD
  PEER
  C_LEVEL
  HR
  DEPT
  SELF
}

enum QuestionType {
  RATING
  TEXT
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
}

enum LeaveType {
  CASUAL
  SICK
  ANNUAL
}

enum LeaveStatus {
  PENDING           // Waiting for approvals
  LEAD_APPROVED     // Lead approved, waiting for HR
  HR_APPROVED       // HR approved, waiting for Lead  
  APPROVED          // Both approved
  REJECTED          // Either rejected
  CANCELLED         // Employee cancelled
}

enum TicketStatus {
  OPEN             // Employee just submitted
  UNDER_REVIEW     // HR is looking at it
  SOLUTION         // HR has a solution, sharing with employee
  RESOLVED         // Issue is closed
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum PayrollPeriodStatus {
  DRAFT
  CALCULATED
  APPROVED
  SENDING
  SENT
  PARTIAL
  FAILED
  LOCKED
}

enum PayrollSourceType {
  WORKBOOK
  MANUAL
  CARRY_FORWARD
}

enum PayrollIdentityStatus {
  AUTO_MATCHED
  MANUAL_MATCHED
  UNRESOLVED
  AMBIGUOUS
}

enum PayrollReceiptStatus {
  DRAFT
  READY
  ENVELOPE_CREATED
  SENT
  COMPLETED
  FAILED
}

enum PayrollImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model User {
  id           String   @id @default(cuid())
  name         String
  email        String?  @unique
  passwordHash    String?  // Hashed password for authentication
  passwordVersion Int      @default(0)
  department      String?
  position     String?
  role         UserRole @default(EMPLOYEE)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Org chart position (optional - used to save custom positions)
  chartX      Float?
  chartY      Float?

  // Relations
  evaluatorMappings   EvaluatorMapping[] @relation("Evaluator")
  evaluateeMappings   EvaluatorMapping[] @relation("Evaluatee")
  evaluations         Evaluation[]
  weightages          Weightage[]
  reports              Report[]
  emailQueue           EmailQueue[]
  
  // Leave management relations
  leaveRequests       LeaveRequest[]     @relation("LeaveEmployee")
  leaveCovering       LeaveRequest[]     @relation("LeaveCover")
  
  // Device management relations
  deviceTickets       DeviceTicket[]     @relation("DeviceTicketEmployee")
  leaveBalances       LeaveBalance[]

  // Payroll management relations
  payrollCreatedPeriods   PayrollPeriod[]         @relation("PayrollCreatedBy")
  payrollApprovedPeriods  PayrollPeriod[]         @relation("PayrollApprovedBy")
  payrollIdentityMappings PayrollIdentityMapping[]
  payrollImportBatches    PayrollImportBatch[]    @relation("PayrollImportedBy")
  payrollExpenseEntries   PayrollExpenseEntry[]   @relation("PayrollExpenseEnteredBy")
  payrollApprovalEvents   PayrollApprovalEvent[]  @relation("PayrollApprovalActor")
  payrollReceipts         PayrollReceipt[]        @relation("PayrollReceiptUser")

  @@index([name])
  @@index([email])
}

model EvaluatorMapping {
  id               String           @id @default(cuid())
  evaluatorId      String
  evaluateeId      String
  relationshipType RelationshipType
  isSelfEvaluation Boolean          @default(false) // Flag for self-evaluations
  createdAt        DateTime         @default(now())

  evaluator User @relation("Evaluator", fields: [evaluatorId], references: [id], onDelete: Cascade)
  evaluatee User @relation("Evaluatee", fields: [evaluateeId], references: [id], onDelete: Cascade)

  @@unique([evaluatorId, evaluateeId, relationshipType])
  @@index([evaluatorId])
  @@index([evaluateeId])
}

model EvaluationQuestion {
  id               String           @id @default(cuid())
  relationshipType RelationshipType
  questionText     String
  questionType     QuestionType     @default(RATING)
  maxRating        Int              @default(4)
  orderIndex       Int
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  evaluations Evaluation[]

  @@unique([relationshipType, orderIndex])
  @@index([relationshipType, orderIndex])
}

model EvaluationPeriod {
  id        String   @id @default(cuid())
  name      String   // e.g., "Q3 2025"
  startDate DateTime
  endDate   DateTime
  isActive  Boolean  @default(true)
  isLocked  Boolean  @default(false) // Prevents new submissions when locked
  reminderSent Boolean @default(false) // Track if deadline reminder was sent
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reports Report[]
  evaluations Evaluation[]

  @@index([isActive])
}

model Evaluation {
  id           String    @id @default(cuid())
  evaluatorId String
  evaluateeId String
  questionId   String
  periodId     String
  ratingValue  Int?
  textResponse String?
  submittedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  evaluator User              @relation(fields: [evaluatorId], references: [id], onDelete: Cascade)
  question  EvaluationQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  period    EvaluationPeriod   @relation(fields: [periodId], references: [id], onDelete: Cascade)

  @@unique([evaluatorId, evaluateeId, questionId, periodId])
  @@index([evaluatorId])
  @@index([evaluateeId])
  @@index([periodId])
}

model Weightage {
  id                 String           @id @default(cuid())
  employeeId         String
  relationshipType   RelationshipType
  weightagePercentage Float
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  employee User @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([employeeId, relationshipType])
  @@index([employeeId])
}

model Report {
  id           String   @id @default(cuid())
  employeeId   String
  periodId     String
  overallScore Float
  breakdownJson Json    // Store detailed breakdown as JSON
  isAnonymized Boolean  @default(false) // Whether evaluator names are hidden
  generatedAt  DateTime @default(now())

  employee User            @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  period   EvaluationPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  emailQueue EmailQueue[]

  @@unique([employeeId, periodId])
  @@index([employeeId])
  @@index([periodId])
}

model EmailQueue {
  id         String      @id @default(cuid())
  employeeId String
  reportId   String?
  emailStatus EmailStatus @default(PENDING)
  scheduledAt DateTime?
  sentAt     DateTime?
  errorMessage String?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  employee User    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  report   Report? @relation(fields: [reportId], references: [id], onDelete: SetNull)

  @@index([emailStatus])
  @@index([employeeId])
}

// Leave Management
model LeaveRequest {
  id              String      @id @default(cuid())
  employeeId      String
  leaveType       LeaveType
  startDate       DateTime
  endDate         DateTime
  reason          String
  transitionPlan  String      // Tasks and handover details
  coverPersonId   String?     // Who covers their tasks
  additionalNotifyIds Json?   // Array of user IDs to CC on email (notification only, not approval)
  status          LeaveStatus @default(PENDING)
  
  leadApprovedBy  String?     // Lead who approved
  leadApprovedAt  DateTime?
  leadComment     String?
  
  hrApprovedBy    String?     // HR who approved
  hrApprovedAt    DateTime?
  hrComment       String?
  
  rejectedBy      String?
  rejectedAt      DateTime?
  rejectionReason String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  employee        User        @relation("LeaveEmployee", fields: [employeeId], references: [id], onDelete: Cascade)
  coverPerson     User?       @relation("LeaveCover", fields: [coverPersonId], references: [id], onDelete: SetNull)

  @@index([employeeId])
  @@index([status])
  @@index([startDate, endDate])
}

model LeaveBalance {
  id          String   @id @default(cuid())
  employeeId  String
  year        Int
  casualDays  Int      @default(10)
  sickDays    Int      @default(6)
  annualDays  Int      @default(14)
  casualUsed  Int      @default(0)
  sickUsed    Int      @default(0)
  annualUsed  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  employee    User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  @@unique([employeeId, year])
  @@index([employeeId])
}

// Weight profiles - maps a set of evaluator categories to their weights
model WeightProfile {
  id              String   @id @default(cuid())
  categorySetKey  String   @unique  // Sorted relationship types joined, e.g. "C_LEVEL,DEPT,DIRECT_REPORT,HR,PEER,TEAM_LEAD"
  displayName     String             // Human-readable, e.g. "Team Lead, Direct Reports, Peer, HR, Hamiz, Dept"
  weights         Json               // { "TEAM_LEAD": 0.15, "DIRECT_REPORT": 0.25, ... }
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// Device Management / IT Support Tickets
model DeviceTicket {
  id            String         @id @default(cuid())
  employeeId    String
  title         String         // Short description
  description   String         // Full problem details
  deviceType    String         // e.g. "Laptop", "Monitor", "Keyboard", etc.
  priority      TicketPriority @default(MEDIUM)
  status        TicketStatus   @default(OPEN)

  // Support-team response fields
  hrAssignedTo              String?        // Current support owner (HR/Security)
  solution                  String?        // Resolution/proposed solution shown to employee
  expectedResolutionDate    DateTime?      // Required when support proposes/commits resolution
  hrNotes                   String?        // Internal HR notes (not visible to security/employee)

  resolvedAt    DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  employee      User           @relation("DeviceTicketEmployee", fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId])
  @@index([status])
}

model PayrollPeriod {
  id            String              @id @default(cuid())
  label         String
  periodStart   DateTime
  periodEnd     DateTime
  status        PayrollPeriodStatus @default(DRAFT)
  sourceType    PayrollSourceType   @default(CARRY_FORWARD)
  currency      String              @default("PKR")
  timezone      String              @default("Asia/Karachi")
  createdById   String
  approvedById  String?
  approvedAt    DateTime?
  lockedAt      DateTime?
  summaryJson   Json?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  createdBy     User                @relation("PayrollCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)
  approvedBy    User?               @relation("PayrollApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
  importBatches PayrollImportBatch[]
  inputValues   PayrollInputValue[]
  computedValues PayrollComputedValue[]
  expenseEntries PayrollExpenseEntry[]
  receipts      PayrollReceipt[]
  approvalEvents PayrollApprovalEvent[]

  @@index([status])
  @@index([periodStart, periodEnd])
  @@index([createdById])
}

model PayrollIdentityMapping {
  id                    String                @id @default(cuid())
  normalizedPayrollName String                @unique
  displayPayrollName    String
  userId                String?
  status                PayrollIdentityStatus @default(UNRESOLVED)
  lastMatchedAt         DateTime?
  notes                 String?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  user                  User?                 @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([userId])
}

model PayrollImportBatch {
  id          String             @id @default(cuid())
  sourceType  PayrollSourceType
  fileName    String?
  importedById String
  periodId    String?
  status      PayrollImportStatus @default(PENDING)
  summaryJson Json?
  errorMessage String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  importedBy  User               @relation("PayrollImportedBy", fields: [importedById], references: [id], onDelete: Restrict)
  period      PayrollPeriod?     @relation(fields: [periodId], references: [id], onDelete: SetNull)
  rows        PayrollImportRow[]

  @@index([sourceType])
  @@index([status])
  @@index([importedById])
  @@index([periodId])
}

model PayrollImportRow {
  id              String           @id @default(cuid())
  batchId         String
  sheetName       String
  rowNumber       Int
  rowJson         Json
  periodKey       String?
  payrollName     String?
  normalizedName  String?
  createdAt       DateTime         @default(now())

  batch           PayrollImportBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@index([batchId])
  @@index([sheetName])
  @@index([periodKey])
  @@index([normalizedName])
}

model PayrollInputValue {
  id            String            @id @default(cuid())
  periodId      String
  payrollName   String
  userId        String?
  componentKey  String
  amount        Float
  sourceSheet   String?
  sourceCell    String?
  sourceMethod  PayrollSourceType @default(MANUAL)
  isOverride    Boolean           @default(false)
  note          String?
  provenanceJson Json?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  period        PayrollPeriod     @relation(fields: [periodId], references: [id], onDelete: Cascade)

  @@unique([periodId, payrollName, componentKey])
  @@index([periodId])
  @@index([userId])
  @@index([componentKey])
}

model PayrollComputedValue {
  id            String        @id @default(cuid())
  periodId      String
  payrollName   String
  userId        String?
  metricKey     String
  amount        Float
  formulaKey    String
  formulaVersion String
  lineageJson   Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  period        PayrollPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)

  @@unique([periodId, payrollName, metricKey])
  @@index([periodId])
  @@index([metricKey])
}

model PayrollExpenseEntry {
  id           String        @id @default(cuid())
  periodId     String
  userId       String?
  payrollName  String?
  categoryKey  String
  description  String?
  amount       Float
  sheetName    String?
  rowRef       String?
  enteredById  String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  period       PayrollPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  enteredBy    User          @relation("PayrollExpenseEnteredBy", fields: [enteredById], references: [id], onDelete: Restrict)

  @@index([periodId])
  @@index([enteredById])
  @@index([categoryKey])
}

model PayrollReceipt {
  id           String               @id @default(cuid())
  periodId     String
  userId       String?
  payrollName  String
  receiptJson  Json
  renderedHtml String?
  status       PayrollReceiptStatus @default(DRAFT)
  version      Int                  @default(1)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  period       PayrollPeriod        @relation(fields: [periodId], references: [id], onDelete: Cascade)
  user         User?                @relation("PayrollReceiptUser", fields: [userId], references: [id], onDelete: SetNull)
  envelopes    PayrollDocuSignEnvelope[]

  @@unique([periodId, payrollName])
  @@index([periodId])
  @@index([userId])
  @@index([status])
}

model PayrollDocuSignEnvelope {
  id            String        @id @default(cuid())
  receiptId     String
  envelopeId    String?       @unique
  recipientName String
  recipientEmail String
  status        String
  sentAt        DateTime?
  completedAt   DateTime?
  lastSyncedAt  DateTime?
  errorMessage  String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  receipt       PayrollReceipt @relation(fields: [receiptId], references: [id], onDelete: Cascade)

  @@index([receiptId])
  @@index([status])
}

model PayrollApprovalEvent {
  id          String              @id @default(cuid())
  periodId    String
  actorId     String
  fromStatus  PayrollPeriodStatus?
  toStatus    PayrollPeriodStatus
  comment     String?
  createdAt   DateTime            @default(now())

  period      PayrollPeriod       @relation(fields: [periodId], references: [id], onDelete: Cascade)
  actor       User                @relation("PayrollApprovalActor", fields: [actorId], references: [id], onDelete: Restrict)

  @@index([periodId])
  @@index([actorId])
}

model PayrollConfig {
  id                String   @id @default(cuid())
  templateId        String
  templateRoleName  String   @default("Employee")
  active            Boolean  @default(true) @unique
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}
